/*
 * This code is part of Rice Comp215 and is made available for your
 * use as a student in Comp215. You are specifically forbidden from
 * posting this code online in a public fashion (e.g., on a public
 * GitHub repository) or otherwise making it, or any derivative of it,
 * available to future Comp215 students. Violations of this rule are
 * considered Honor Code violations and will result in your being
 * reported to the Honor Council, even after you've completed the
 * class, and will result in retroactive reductions to your grade. For
 * additional details, please see the Comp215 course syllabus.
 */

package edu.rice.prettypictures;

import static edu.rice.util.Strings.stringToOptionInteger;
import static io.vavr.control.Option.none;
import static io.vavr.control.Option.some;
import static java.lang.Math.abs;
import static java.lang.Math.round;

import edu.rice.json.Value;
import edu.rice.json.Value.JNumber;
import io.vavr.collection.List;
import io.vavr.collection.Seq;
import io.vavr.control.Option;
import java.awt.image.BufferedImage;

/**
 * This class represents an RGB color. It uses an internal floating point representation where
 * colors are 3-tuples of numbers between -1 (black) and 1 (white). It's perfectly permissible for
 * these colors to be outside of the range of [-1,1], however when converting to ARGB (packed 32-bit
 * integer format), colors will be clipped, and alpha will always be 255 (fully opaque).
 *
 * <p>There are a large number of helpful maker-methods here, all named "color", which can convert
 * from pretty much whatever you've got to an RgbColor. When some degree of parsing is required, the
 * results will be an Option (e.g., {@link #color(Value)}). Otherwise, the results will be an
 * RgbColor directly (e.g., {@link #color(int)}.
 *
 * <p>This class supports input and output with <i>three</i> external formats: JSON values, lists of
 * doubles, and 32-bit packed integers.
 *
 * <ul>
 *   <li>To convert to and from lists of double, use {@link #toList()} and {@link #color(Seq)}.
 *   <li>To convert to and from packed 32-bit (ARGB) integers, use {@link #toRgb()} and {@link
 *       #color(int)}.
 *   <li>To convert from JSON, use {@link #color(Value)}. JSON output is handled in {@link
 *       GeneTree#toJson()}.
 * </ul>
 */
public class RgbColor {
  public final double r;
  public final double g;
  public final double b;

  // for internal use only; see static methods below
  private RgbColor(double r, double g, double b) {
    this.r = r;
    this.g = g;
    this.b = b;
  }

  private static final double EQUALS_DELTA = 0.01;

  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (!(o instanceof RgbColor)) {
      return false;
    }

    // When you save and reload these things, there may be some noise
    // in the low bit of the color, which can screw up unit tests and
    // such. The solution, while it seems a bit cheesy, is to compare
    // the floating point representations to within the given
    // EQUALS_DELTA of each other.

    var other = (RgbColor) o;

    return abs(other.r - r) < EQUALS_DELTA
        && abs(other.g - g) < EQUALS_DELTA
        && abs(other.b - b) < EQUALS_DELTA;
  }

  @Override
  public int hashCode() {
    // We're going to use a color's packed integer representation as our hashCode().
    // Doesn't necessarily give good spreading in a hash table, but cheap to compute.
    return toRgb();
  }

  /**
   * Converts an RgbColor to a list of three doubles, corresponding to the [-1,1]-ranged numbers for
   * red, green, and blue.
   */
  public Seq<Double> toList() {
    return List.of(r, g, b);
  }

  /**
   * Given a list of three strings with 0-to-1 floating point numbers within, such as generated by
   * {@link #toList()}, converts back to an RgbColor.
   */
  public static Option<RgbColor> color(Seq<Double> colorNumbers) {
    if (colorNumbers.length() != 3) {
      return none();
    } else {
      return some(color(colorNumbers.get(0), colorNumbers.get(1), colorNumbers.get(2)));
    }
  }

  /** Creates an RgbColor from a string with a hexadecimal color (two digits each RRGGBB). */
  public static Option<RgbColor> color(String hexColor) {
    if (hexColor.length() != 6) {
      return none();
    } else {
      return stringToOptionInteger(hexColor, 16).map(RgbColor::color);
    }
  }

  /**
   * Create an RgbColor from a JSON representation. If the input JSON value isn't correctly
   * formatted, {@link Option#none()} is returned. Two separate JSON forms are accepted:
   *
   * <ul>
   *   <li>A JSON array with three numbers, ranging from [-1,1] (as used in {@link #color(double,
   *       double, double)})
   *   <li>A string with six hexadecimal digits, RRGGBB (as used in {@link #color(String)})
   * </ul>
   */
  public static Option<RgbColor> color(Value json) {
    return json.match(
        jObject -> none(),
        jArray -> {
          final var input = jArray.getSeq();

          // we want exactly three entries in the JSON array
          if (input.length() != 3) {
            return none();
          }

          final var contents = input.flatMap(Value::asJNumberOption).map(JNumber::get);

          // we want exactly three numbers and nothing else
          if (contents.length() != 3) {
            return none();
          } else {
            return some(color(contents.head(), contents.get(1), contents.get(2)));
          }
        },
        jString -> color(jString.toUnescapedString()),
        jNumber -> none(),
        jBoolean -> none(),
        jNull -> none());
  }

  /** Maker-method for RgbColor, using our representation that colors vary from -1.0 to 1.0. */
  public static RgbColor color(double r, double g, double b) {
    return new RgbColor(r, g, b);
  }

  /**
   * Creates an RgbColor from a packed (ARGB) 32-bit integer RGB value (8 bits per channel, alpha
   * ignored). This maker-method is suitable for use with the values returned by {@link
   * BufferedImage#getRGB(int, int)}.
   */
  public static RgbColor color(int rgb) {
    var r = (rgb >> 16) & 0xFF;
    var g = (rgb >> 8) & 0xFF;
    var b = rgb & 0xFF;
    return color((r / 127.5) - 1, (g / 127.5) - 1, (b / 127.5) - 1);
  }

  @Override
  public String toString() {
    return String.format("RgbColor(%.3f, %.3f, %.3f)", r, g, b);
  }

  private static int clip(double f) {
    var fixed = (int) round(127.5 * (f + 1));
    return fixed < 0 ? 0 : Math.min(fixed, 255);
  }

  /**
   * Returns a packed 32-bit integer representation of this RgbColor, suitable for use with {@link
   * BufferedImage}. Note that the "alpha" channel will be "FF" rather than 0. This ensures that our
   * colors are "solid" rather than "transparent".
   */
  public int toRgb() {
    return 0xFF000000
        | (0x00FF0000 & (clip(r) << 16))
        | (0x0000FF00 & (clip(g) << 8))
        | (0x000000FF & clip(b));
  }

  /** Returns a String representing the color as a base-16 number (RRGGBB). */
  public String toHexColor() {
    return String.format("%02x%02x%02x", clip(r), clip(g), clip(b));
  }
}
